// Generate with
// flatc --scoped-enums --reflect-names --gen-mutable -c noodles.fbs

namespace noodles;


/*

Update semantics:
- Some objects can be updated, some cannot. 
- Unless otherwise specified, updates are value-like atomic. That is, the 
  client should reconstruct the local representation of the entity. This is
  opposed to a non-atomic delta-like update; where only mentioned fields in the 
  table should be updated in the local representation. Note that in non-atomic 
  mode, updates cannot (of course) change the ID of the object. However, 
  updates to the "name" field is to be ignored on the client, and not done by 
  the server.

Coordinate system semantics:
- We follow the GLTF style for coordinates and orientations (right handed).
- Units are in SI.
- Lengths are in meters.

*/

// =============================================================================
// Common Types ================================================================
// =============================================================================

// This API is defined around handles to things.
// Identifiers are tables, due to poor language support for structs.
// If any of the slot or gen fields are maximum, then the handle is null.
table EntityID {
    id_slot : uint32 = 4294967295;
    id_gen  : uint32 = 4294967295;
}

table PlotID {
    id_slot : uint32 = 4294967295;
    id_gen  : uint32 = 4294967295;
}

table TableID {
    id_slot : uint32 = 4294967295;
    id_gen  : uint32 = 4294967295;
}

table SignalID {
    id_slot : uint32 = 4294967295;
    id_gen  : uint32 = 4294967295;
}

table MethodID {
    id_slot : uint32 = 4294967295;
    id_gen  : uint32 = 4294967295;
}

table MaterialID {
    id_slot : uint32 = 4294967295;
    id_gen  : uint32 = 4294967295;
}

table GeometryID {
    id_slot : uint32 = 4294967295;
    id_gen  : uint32 = 4294967295;
}

table LightID {
    id_slot : uint32 = 4294967295;
    id_gen  : uint32 = 4294967295;
}

table ImageID {
    id_slot : uint32 = 4294967295;
    id_gen  : uint32 = 4294967295;
}

table TextureID {
    id_slot : uint32 = 4294967295;
    id_gen  : uint32 = 4294967295;
}

table SamplerID {
    id_slot : uint32 = 4294967295;
    id_gen  : uint32 = 4294967295;
}

table BufferID {
    id_slot : uint32 = 4294967295;
    id_gen  : uint32 = 4294967295;
}

table BufferViewID {
    id_slot : uint32 = 4294967295;
    id_gen  : uint32 = 4294967295;
}

union AnyIDType {
    EntityID,
    TableID,
    SignalID,
    MethodID,
    MaterialID,
    GeometryID,
    LightID,
    ImageID,
    TextureID,
    SamplerID,
    BufferID,
    BufferViewID,
    PlotID
}

union InvokeIDType {
    EntityID,
    TableID,
    PlotID
}

table AnyID {
    id : AnyIDType (required);
}

table MapEntry {
    name  : string (key);
    value : Any;
}

table Text { text : string; }
table Integer { integer : int64; }
table IntegerList { integers : [int64]; }
table Real { real : double; }
table RealList { reals : [double]; }
table Data { data : [byte]; }
table AnyList { list : [Any]; }
table AnyMap { entries : [MapEntry]; }

union AnyType {
    Text,
    Integer,
    IntegerList,
    Real,
    RealList,
    Data,
    AnyList,
    AnyMap,
    AnyID,
    Vec2,
    Vec3,
    Vec4,
    Mat3,
    Mat4,
    RGBA,
}

table Any {
    any : AnyType;
}

enum Format : byte {
    U8,
    U16,
    U32,

    U8VEC4,

    U16VEC2,

    VEC2,
    VEC3,
    VEC4,

    MAT3,
    MAT4,
}

// Misc Types ==================================================================

struct Vec2 {
    x : float;
    y : float;
}

struct Vec3 {
    x : float;
    y : float;
    z : float;
}

struct Vec4 {
    x : float;
    y : float;
    z : float;
    w : float;
}

struct Mat3 {
    // for javascript compat, we have to expand the below:
    // components : [float : 9];
    c1 : Vec3;
    c2 : Vec3;
    c3 : Vec3;
}

struct Mat4 {
    // for javascript compat, we have to expand the below:
    // components : [float : 16];
    c1 : Vec4;
    c2 : Vec4;
    c3 : Vec4;
    c4 : Vec4;
}

struct BoundingBox {
    aabb_min : Vec3;
    aabb_max : Vec3;
}

struct RGB {
    r : uint8;
    g : uint8;
    b : uint8;
}

struct RGBA {
    r : uint8;
    g : uint8;
    b : uint8;
    a : uint8;
}

// =============================================================================
// Server Messages =============================================================
// =============================================================================

table MethodArg {
    // What is the name for this method argument?
    name : string (required);

    // Documentation for users; what does this argument do?
    doc  : string;

    // Optional hint of the type of this argument
    // Any value in AnyType (as text) is valid.
    hint : string;

    // Optional Control hint for gui editors.
    // Currently known values
    // - 'EditCheckbox'
    // - 'EditSlider:min:max:step'
    editor_hint : string;
}

// Create a new method
table MethodCreate {
    // Depending on the application, multiple methods might have the same name
    // This can cause some confusion; avoid it by prefixes, etc.

    id            : MethodID (required); // The new method's ID
    name          : string (required);   // Non-unique name of method
    documentation : string;              // Optional docstring for method
    return_doc    : string;              // Optional return value documentation
    arg_doc       : [ MethodArg ];       // Arguments to method
}

// Destroy a method
table MethodDelete {
    id : MethodID (required);
}

// =============================================================================

// Create a new signal
table SignalCreate {
    id             : SignalID (required); // The new signal's ID
    name           : string (required);   // Non-unique name of signal
    documentation  : string;              // Optional signal docstring
    arg_doc        : [ MethodArg ];       // Data provided with signal
}

// Delete a signal
table SignalDelete {
    id : SignalID (required);
}

// =============================================================================

// The 'has no visual representation' type
table EmptyDefinition {
    // Tables cannot be empty, which breaks the variant model.
    // In any case, this field is completely ignored.
    padding : bool = false; 
}

// Render this entity as text
table TextDefinition { // Text plane, normal -z, up is +y, center: obj origin
    text   : string (required); // String to render
    font   : string (required); // Approximate font to use (e.g. Arial)
    height : float = .25; // The height of the text plane.
    width  : float = -1; // Optional width of text, infer from height if < 0
}

// Render this entity as a web page. This is done by defining a plane on which
// to paint the page
table WebpageDefinition {
    url    : string (required); // Where should we fetch the page?
    height : float = .5;        // the physical height of the page 'plane'
    width  : float = .5;        // the physical width of the page
}

// Render this entity as a mesh
table RenderableDefinition {
    material    : MaterialID (required);
    mesh        : [GeometryID] (required);
    instances   : StructuredAttribute; // optional, only mat4 allowed
    instance_bb : BoundingBox; // optional override for instanced object culling
}

union Representation {
    EmptyDefinition,
    TextDefinition,
    WebpageDefinition,
    RenderableDefinition
}

struct EntityVisibility {
    // Should this entity even be visible? By default all renderable items are
    // visible, but there are times when you want to switch something off
    // temporarily
    visible : bool;  
}

// Create or update an entity.
// Non-atomic update semantics
table EntityCreateUpdate {
    // either the new id of the entity or the entity to update
    id        : EntityID (required); 
    name      : string;   // optional name of this entity
    parent    : EntityID; // optional parent of this entity. DO NOT CREATE LOOPS
    transform : Mat4;     // optional transform; if missing, assume identity

    representation : Representation; // optional drawable representation

    lights       : [LightID]; // optional lights attached
    tables       : [TableID]; // optional tables attached
    plots        : [PlotID];  // optional plots attached
    tags         : [string];  // optional tags
    methods_list : [MethodID]; // optional attached methods
    signals_list : [SignalID]; // " " signals. avoid "signals" for Qt.

    // optional region of influence, for interaction; edge case for when a 
    // user is clicking empty space, but you want this entity to catch it.
    influence : BoundingBox; 

    visibility : EntityVisibility; // optional visibility
}

table EntityDelete {
    id : EntityID (required);
}

// =============================================================================

table SimplePlot {
    // this plot uses a simple language. TBD
    definition : string (required);
}

table URLPlot {
    // this plot is defined as a webpage. 
    url : string (required);
}

union PlotType {
    SimplePlot,
    URLPlot
}

// non-atomic update semantics
table PlotCreateUpdate {
    // ID of the plot to either create or update
    id           : PlotID (required);
    name         : string;   // optional name of the plot
    table_ref    : TableID;  // optional link to a table of data
    type         : PlotType (required); // type of this plot
    methods_list : [MethodID]; // optional attached methods
    signals_list : [SignalID]; // optional attached signals
}

table PlotDelete {
    id : PlotID (required);
}

// ===========================================================================

table InlineSource {
    bytes : [byte] (required);
}

table URLSource {
    url : string (required);
}

union BufferSource {
    InlineSource, // either an inline set of bytes
    URLSource     // or a URL to load
}

// A buffer describes a source of bytes to read from
table BufferCreate {
    // ID of the buffer to either create or update
    id    : BufferID (required);
    name  : string; // optional name of this buffer
    size  : uint64; // Size of buffer, if missing or zero, invalid

    // where does the data come from?
    source : BufferSource;
}

table BufferDelete {
    id    : BufferID (required);
}

// =============================================================================

enum ViewType : byte {
    UNKNOWN,
    GEOMETRY_INFO, // Data contains geometry information (vertex, index)
    IMAGE_INFO,    // Data contains an image
}

// Defines a subrange of a buffer, with a hint as to the data contained within.
table BufferViewCreate {
    // ID of the buffer view to either create or update
    id            : BufferViewID (required);
    name          : string; // optional name of this view
    source_buffer : BufferID (required); // Buffer this view looks at

    type   : ViewType; // Type hint for this buffer
    offset : uint64 = 0; // Offset into the buffer of this range
    length : uint64 = 0; // Length of this range
}

table BufferViewDelete {
    id    : BufferID (required);
}

// =============================================================================

// A reference to a texture
table TextureRef {
    texture_id         : TextureID (required);

    // texture coordinate transform. If missing, identity
    transform          : Mat3; 
    
    // texture coordinate channel of a mesh to be used in mapping
    texture_coord_slot : uint8;
}

table PBRInfo {
    base_color          : RGBA; // default is 255 for all channels.
    base_color_texture  : TextureRef; // assumed to be SRGB. no premult alpha

    metallic            : float = 1;
    roughness           : float = 1;
    metal_rough_texture : TextureRef; // assumed to be linear. ONLY RG used
}

// non-atomic update semantics
table MaterialCreateUpdate {
    // ID of the new material or the material to update
    id   : MaterialID (required);
    name : string;

    pbr_info       : PBRInfo; // if missing, assume defaults.
    normal_texture : TextureRef; // if missing, no normal mapping

    occlusion_texture        : TextureRef; // assumed to be linear. ONLY R
    occlusion_texture_factor : float = 1;

    emissive_texture : TextureRef; // assumed to be SRGB. ignore A.
    emissive_factor  : Vec3;

    use_alpha    : bool  = false;
    alpha_cutoff : float = .5;

    double_sided : bool = false;
}

table MaterialDelete {
    id           : MaterialID (required);
}

// =============================================================================

union ImageSource {
    BufferViewID, // Either a reference to a buffer
    URLSource // Or a URL to load from
}

// Images may come in a variety of formats
// - PNG
// - JPEG
// - KTX2
// PNG and JPEG should be supported, KTX2 may be ignored
table ImageCreate {
    // ID of the image to create
    id       : ImageID (required);
    name     : string; // name of this image

    // color space information must be ignored
    source : ImageSource;
}

table ImageDelete {
    id : ImageID (required);
}

// =============================================================================

// Textures may be assumed to be in SRGB. If so, they must be decoded to linear
// before use in shaders, etc.
table TextureCreate {
    id   : TextureID (required);
    name : string;

    image   : ImageID (required);
    sampler : SamplerID; // optional, if missing default sampler
}

table TextureDelete {
    id : TextureID (required);
}

// =============================================================================

enum MagFilter : byte {
    NEAREST,
    LINEAR,
}

enum MinFilter : byte {
    NEAREST,
    LINEAR,
    NEAREST_MIPMAP_NEAREST,
    LINEAR_MIPMAP_NEAREST,
    NEAREST_MIPMAP_LINEAR,
    LINEAR_MIPMAP_LINEAR,
}

enum SamplerMode : byte {
    CLAMP_TO_EDGE,
    MIRRORED_REPEAT,
    REPEAT,
}

table SamplerCreate {
    id   : SamplerID (required);
    name : string;

    mag_filter : MagFilter;
    min_filter : MinFilter;

    wrap_s : SamplerMode = REPEAT;
    wrap_t : SamplerMode = REPEAT;
}

table SamplerDelete {
    id : SamplerID (required);
}

// =============================================================================

table PointLight {
    range : float = -1;
}

table SpotLight {
    //Direct light along -Z
    range : float = -1;
    inner_cone_angle_rad : float = 0;
    outer_cone_angle_rad : float = 0.7853981633974483; // PI/4.0
}

table DirectionLight {
    //Direct light along -Z
    range : float = -1;
}

union LightType {
    PointLight,
    SpotLight, 
    DirectionLight,
}

// non-atomic update semantics
table LightCreateUpdate {
    id         : LightID (required);
    name       : string;

    color      : RGB; // Linear space, default pure white
    intensity  : float = 1.0;

    light_type : LightType; // after being set once, updates ignored
}

table LightDelete {
    id : LightID (required);
}

// =============================================================================

// Interpret a view as a strided pack of vector or matrix elements
table StructuredAttribute { 
    // All elements required, but not expressable in this spec
    id     : BufferViewID (required);
    stride : uint64 = 0;
    format : Format;
}

enum PrimitiveType : byte {
    POINTS,
    LINES,
    LINE_LOOP,
    LINE_STRIP,
    TRIANGLES,
    TRIANGLE_STRIP,
    TRIANGLE_FAN
}

table GeometryPatch {
    // renderable extent of this geometry patch
    extent : BoundingBox;

    positions  : StructuredAttribute; // at the moment, should only be vec3
    normals    : StructuredAttribute; // at the moment, should only be vec3
    tangent    : StructuredAttribute; // at the moment, should only be vec3
    tex_coords : StructuredAttribute; // vec2, u16vec2
    colors     : StructuredAttribute; // u8vec4

    // optional, if missing, non-indexed primitives only
    indicies   : StructuredAttribute; // u8, u16, u32

    type : PrimitiveType = TRIANGLES;
}

table GeometryCreate {
    id      : GeometryID (required); // id of the new geometry
    name    : string;
    patches : [ GeometryPatch ];    
}

table GeometryDelete {
    id : GeometryID (required);
}

// =============================================================================

// non-atomic update semantics
table TableCreateUpdate {
    id           : TableID (required);
    name         : string;
    meta         : string;
    methods_list : [ MethodID ];
    signals_list : [ SignalID ];
}

table TableDelete {
    id      : TableID (required);
}

// =============================================================================

table DocumentUpdate {
    methods_list  : [ MethodID ];
    signals_list  : [ SignalID ];
}

table DocumentReset {
    padding : bool; // these things cannot be empty, so...
}

// =============================================================================

table SignalInvoke {
    id  : SignalID (required);

    // if not set, it is on the document
    on_object : InvokeIDType;

    signal_data  : AnyList;
}

table MethodException {
    code    : int64;  // required
    message : string; // optional
    data    : Any;    // optional
}

table MethodReply {
    invoke_ident     : string (required);
    method_data      : Any;             // optional
    method_exception : MethodException; // optional
}

// =============================================================================

union ServerMessageType {
    MethodCreate,
    MethodDelete,
    SignalCreate,
    SignalDelete,
    EntityCreateUpdate,
    EntityDelete,
    BufferCreate,
    BufferDelete,
    BufferViewCreate,
    BufferViewDelete,
    MaterialCreateUpdate,
    MaterialDelete,
    TextureCreate,
    TextureDelete,
    SamplerCreate,
    SamplerDelete,
    ImageCreate,
    ImageDelete,
    LightCreateUpdate,
    LightDelete,
    GeometryCreate,
    GeometryDelete,
    TableCreateUpdate,
    TableDelete,
    DocumentUpdate,
    DocumentReset,
    SignalInvoke,
    MethodReply
}

table ServerMessage {
    message : ServerMessageType;
}

// Root type for server messages
table ServerMessages {
    messages : [ ServerMessage ];
}

// =============================================================================
// Client Messages =============================================================
// =============================================================================

table IntroductionMessage {
    client_name : string (required);
}

table MethodInvokeMessage {
    method_id : MethodID (required);

    // if not set, it is on the document
    on_object : InvokeIDType;

    invoke_ident : string;
    method_args  : AnyList;
}

union ClientMessageType {
    IntroductionMessage,
    MethodInvokeMessage,
}

table ClientMessage {
    content : ClientMessageType (required);
}

// Root type for client messages
table ClientMessages {
    messages : [ ClientMessage ] (required);
}
