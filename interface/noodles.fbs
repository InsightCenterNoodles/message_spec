// Generate with
// flatc --scoped-enums --reflect-names --gen-mutable -c noodles.fbs

namespace noodles;


/*

Update semantics:
- Some objects can be updated, some cannot. 
- Unless otherwise specified, updates are value-like atomic. That is, the 
  client should reconstruct the local representation of the entity. This is
  opposed to a non-atomic delta-like update; where only mentioned fields in the 
  table should be updated in the local representation. Note that in non-atomic 
  mode, updates cannot (of course) change the ID of the object. However, 
  updates to the "name" field is to be ignored on the client, and not done by 
  the server.

Coordinate system semantics:
- We follow the GLTF style for coordinates and orientations (right handed).
- Units are in SI.
- Lengths are in meters.

*/

// =============================================================================
// Common Types ================================================================
// =============================================================================

// This API is defined around handles to things.
// Identifiers are tables, due to poor language support for structs.
// If any of the slot or gen fields are maximum, then the handle is null.
table EntityID {
    id_slot : uint32 = 4294967295;
    id_gen  : uint32 = 4294967295;
}

table PlotID {
    id_slot : uint32 = 4294967295;
    id_gen  : uint32 = 4294967295;
}

table TableID {
    id_slot : uint32 = 4294967295;
    id_gen  : uint32 = 4294967295;
}

table SignalID {
    id_slot : uint32 = 4294967295;
    id_gen  : uint32 = 4294967295;
}

table MethodID {
    id_slot : uint32 = 4294967295;
    id_gen  : uint32 = 4294967295;
}

table MaterialID {
    id_slot : uint32 = 4294967295;
    id_gen  : uint32 = 4294967295;
}

table GeometryID {
    id_slot : uint32 = 4294967295;
    id_gen  : uint32 = 4294967295;
}

table LightID {
    id_slot : uint32 = 4294967295;
    id_gen  : uint32 = 4294967295;
}

table ImageID {
    id_slot : uint32 = 4294967295;
    id_gen  : uint32 = 4294967295;
}

table TextureID {
    id_slot : uint32 = 4294967295;
    id_gen  : uint32 = 4294967295;
}

table SamplerID {
    id_slot : uint32 = 4294967295;
    id_gen  : uint32 = 4294967295;
}

table BufferID {
    id_slot : uint32 = 4294967295;
    id_gen  : uint32 = 4294967295;
}

table BufferViewID {
    id_slot : uint32 = 4294967295;
    id_gen  : uint32 = 4294967295;
}

union AnyIDType {
    EntityID,
    TableID,
    SignalID,
    MethodID,
    MaterialID,
    GeometryID,
    LightID,
    ImageID,
    TextureID,
    SamplerID,
    BufferID,
    BufferViewID,
    PlotID
}

union InvokeIDType {
    EntityID,
    TableID,
    PlotID
}

table AnyID {
    id : AnyIDType (required);
}

table MapEntry {
    name  : string (key);
    value : Any;
}

table Text { text : string; }
table Integer { integer : int64; }
table IntegerList { integers : [int64]; }
table Real { real : double; }
table RealList { reals : [double]; }
table Data { data : [byte]; }
table AnyList { list : [Any]; }
table AnyMap { entries : [MapEntry]; }
// due to a limitation of FB, we can't have structs in a union. Therefore...
table AVec2 {
    x : float;
    y : float;
}

table AVec3 {
    x : float;
    y : float;
    z : float;
}

table AVec4 {
    x : float;
    y : float;
    z : float;
    w : float;
}

union AnyType {
    Text,
    Integer,
    IntegerList,
    Real,
    RealList,
    Data,
    AnyList,
    AnyMap,
    AnyID,
    AVec2,
    AVec3,
    AVec4,
}

table Any {
    any : AnyType;
}

enum Format : byte {
    U8,
    U16,
    U32,

    U8VEC4,

    U16VEC2,

    VEC2,
    VEC3,
    VEC4,

    MAT3,
    MAT4,
}

// Misc Types ==================================================================

struct Vec2 {
    x : float;
    y : float;
}

struct Vec3 {
    x : float;
    y : float;
    z : float;
}

struct Vec4 {
    x : float;
    y : float;
    z : float;
    w : float;
}

struct Mat3 {
    // for javascript compat, we have to expand the below:
    // components : [float : 9];
    c1 : Vec3;
    c2 : Vec3;
    c3 : Vec3;
}

struct Mat4 {
    // for javascript compat, we have to expand the below:
    // components : [float : 16];
    c1 : Vec4;
    c2 : Vec4;
    c3 : Vec4;
    c4 : Vec4;
}

struct BoundingBox {
    aabb_min : Vec3;
    aabb_max : Vec3;
}

struct RGB {
    r : uint8;
    g : uint8;
    b : uint8;
}

struct RGBA {
    r : uint8;
    g : uint8;
    b : uint8;
    a : uint8;
}

// =============================================================================
// Server Messages =============================================================
// =============================================================================

table MethodArg {
    // What is the name for this method argument?
    name : string (required);

    // Documentation for users; what does this argument do?
    doc  : string;

    // Optional hint of the type of this argument
    // Any value in AnyType (as text) is valid.
    hint : string;

    // Optional Control hint for gui editors.
    // Currently known values
    // - 'EditCheckbox'
    // - 'EditSlider:min:max:step'
    editor_hint : string;
}

// Create a new method
table MethodCreate {
    // Depending on the application, multiple methods might have the same name
    // This can cause some confusion; avoid it by prefixes, etc.

    id            : MethodID (required); // The new method's ID
    name          : string (required);   // Non-unique name of method
    documentation : string;              // Optional docstring for method
    return_doc    : string;              // Optional return value documentation
    arg_doc       : [ MethodArg ];       // Arguments to method
}

// Destroy a method
table MethodDelete {
    id : MethodID (required);
}

// =============================================================================

// Create a new signal
table SignalCreate {
    id             : SignalID (required); // The new signal's ID
    name           : string (required);   // Non-unique name of signal
    documentation  : string;              // Optional signal docstring
    arg_doc        : [ MethodArg ];       // Data provided with signal
}

// Delete a signal
table SignalDelete {
    id : SignalID (required);
}

// =============================================================================

// The 'has no visual representation' type
table EmptyDefinition {
    // Tables cannot be empty, which breaks the variant model.
    // In any case, this field is completely ignored.
    padding : bool = false; 
}

// Render this entity as text
table TextDefinition { // Text plane, normal -z, up is +y, center: obj origin
    text   : string (required); // String to render
    font   : string (required); // Approximate font to use (e.g. Arial)
    height : float = .25; // The height of the text plane.
    width  : float = -1; // Optional width of text, infer from height if < 0
}

// Render this entity as a web page. This is done by defining a plane on which
// to paint the page
table WebpageDefinition {
    url    : string (required); // Where should we fetch the page?
    height : float = .5;        // the physical height of the page 'plane'
    width  : float = .5;        // the physical width of the page
}

table InstanceSemantic {
    view     : BufferViewID;
    // bytes between instance matrices. For best performance, there should be
    // no padding.
    stride : uint64 = 0; 
}

// Render this entity as a mesh
table RenderableDefinition {
    material    : MaterialID (required);
    mesh        : [GeometryID] (required);
    instances   : InstanceSemantic; // optional
    instance_bb : BoundingBox; // optional override for instanced object culling
}

union Representation {
    EmptyDefinition,
    TextDefinition,
    WebpageDefinition,
    RenderableDefinition
}

struct EntityVisibility {
    // Should this entity even be visible? By default all renderable items are
    // visible, but there are times when you want to switch something off
    // temporarily
    visible : bool;  
}

// Create or update an entity.
// Non-atomic update semantics
table EntityCreateUpdate {
    // either the new id of the entity or the entity to update
    id        : EntityID (required); 
    name      : string;   // optional name of this entity
    parent    : EntityID; // optional parent of this entity. DO NOT CREATE LOOPS
    transform : Mat4;     // optional transform; if missing, assume identity

    representation : Representation; // optional drawable representation

    lights       : [LightID]; // optional lights attached
    tables       : [TableID]; // optional tables attached
    plots        : [PlotID];  // optional plots attached
    tags         : [string];  // optional tags
    methods_list : [MethodID]; // optional attached methods
    signals_list : [SignalID]; // " " signals. avoid "signals" for Qt.

    // optional region of influence, for interaction; edge case for when a 
    // user is clicking empty space, but you want this entity to catch it.
    influence : BoundingBox; 

    visibility : EntityVisibility; // optional visibility
}

table EntityDelete {
    id : EntityID (required);
}

// =============================================================================

table SimplePlot {
    // this plot uses a simple language. TBD
    definition : string (required);
}

table URLPlot {
    // this plot is defined as a webpage. 
    url : string (required);
}

union PlotType {
    SimplePlot,
    URLPlot
}

// non-atomic update semantics
table PlotCreateUpdate {
    // ID of the plot to either create or update
    id           : PlotID (required);
    name         : string;   // optional name of the plot
    table_ref    : TableID;  // optional link to a table of data
    type         : PlotType (required); // type of this plot
    methods_list : [MethodID]; // optional attached methods
    signals_list : [SignalID]; // optional attached signals
}

table PlotDelete {
    id : PlotID (required);
}

// ===========================================================================

table InlineSource {
    bytes : [byte] (required);
}

table URLSource {
    url : string (required);
}

union BufferSource {
    InlineSource, // either an inline set of bytes
    URLSource     // or a URL to load
}

// A buffer describes a source of bytes to read from
table BufferCreate {
    // ID of the buffer to either create or update
    id    : BufferID (required);
    name  : string; // optional name of this buffer
    size  : uint64; // Size of buffer, if missing or zero, invalid

    // where does the data come from?
    source : BufferSource;
}

table BufferDelete {
    id    : BufferID (required);
}

// =============================================================================

enum ViewType : byte {
    UNKNOWN,
    GEOMETRY_INFO, // Data contains geometry information (vertex, index)
    IMAGE_INFO,    // Data contains an image
}

// Defines a subrange of a buffer, with a hint as to the data contained within.
table BufferViewCreate {
    // ID of the buffer view to either create or update
    id            : BufferViewID (required);
    name          : string; // optional name of this view
    source_buffer : BufferID (required); // Buffer this view looks at

    type   : ViewType; // Type hint for this buffer
    offset : uint64 = 0; // Offset into the buffer of this range
    length : uint64 = 0; // Length of this range
}

table BufferViewDelete {
    id    : BufferID (required);
}

// =============================================================================

// A reference to a texture
table TextureRef {
    texture_id         : TextureID (required);

    // texture coordinate transform. If missing, identity
    transform          : Mat3; 
    
    // texture coordinate channel of a mesh to be used in mapping
    texture_coord_slot : uint8;
}

table PBRInfo {
    base_color          : RGBA; // default is 255 for all channels.
    base_color_texture  : TextureRef; // assumed to be SRGB. no premult alpha

    metallic            : float = 1;
    roughness           : float = 1;
    metal_rough_texture : TextureRef; // assumed to be linear. ONLY RG used
}

// non-atomic update semantics
table MaterialCreateUpdate {
    // ID of the new material or the material to update
    id   : MaterialID (required);
    name : string;

    pbr_info       : PBRInfo; // if missing, assume defaults.
    normal_texture : TextureRef; // if missing, no normal mapping

    occlusion_texture        : TextureRef; // assumed to be linear. ONLY R
    occlusion_texture_factor : float = 1;

    emissive_texture : TextureRef; // assumed to be SRGB. ignore A.
    emissive_factor  : Vec3;

    use_alpha    : bool  = false;
    alpha_cutoff : float = .5;

    double_sided : bool = false;
}

table MaterialDelete {
    id           : MaterialID (required);
}

// =============================================================================

union ImageSource {
    BufferViewID, // Either a reference to a buffer
    URLSource // Or a URL to load from
}

// Images may come in a variety of formats
// - PNG
// - JPEG
// - KTX2
// PNG and JPEG should be supported, KTX2 may be ignored
table ImageCreate {
    // ID of the image to create
    id       : ImageID (required);
    name     : string; // name of this image

    // color space information must be ignored
    source : ImageSource;
}

table ImageDelete {
    id : ImageID (required);
}

// =============================================================================

// Textures may be assumed to be in SRGB. If so, they must be decoded to linear
// before use in shaders, etc.
table TextureCreate {
    id   : TextureID (required);
    name : string;

    image   : ImageID (required);
    sampler : SamplerID; // optional, if missing default sampler
}

table TextureDelete {
    id : TextureID (required);
}

// =============================================================================

enum MagFilter : byte {
    NEAREST,
    LINEAR,
}

enum MinFilter : byte {
    NEAREST,
    LINEAR,
    NEAREST_MIPMAP_NEAREST,
    LINEAR_MIPMAP_NEAREST,
    NEAREST_MIPMAP_LINEAR,
    LINEAR_MIPMAP_LINEAR,
}

enum SamplerMode : byte {
    CLAMP_TO_EDGE,
    MIRRORED_REPEAT,
    REPEAT,
}

table SamplerCreate {
    id   : SamplerID (required);
    name : string;

    mag_filter : MagFilter;
    min_filter : MinFilter;

    wrap_s : SamplerMode = REPEAT;
    wrap_t : SamplerMode = REPEAT;
}

table SamplerDelete {
    id : SamplerID (required);
}

// =============================================================================

// Lights are defined to mirror the GLTF punctual light extension

// A point light source
table PointLight {
    range : float = -1;
}

table SpotLight {
    //Direct light along -Z
    range : float = -1;
    inner_cone_angle_rad : float = 0;
    outer_cone_angle_rad : float = 0.7853981633974483; // PI/4.0
}

table DirectionLight {
    //Direct light along -Z
    range : float = -1;
}

union LightType {
    PointLight,
    SpotLight, 
    DirectionLight,
}

// non-atomic update semantics
table LightCreateUpdate {
    id         : LightID (required);
    name       : string;

    color      : RGB; // Linear space, default pure white
    intensity  : float = 1.0;

    light_type : LightType; // after being set once, updates ignored
}

table LightDelete {
    id : LightID (required);
}

// =============================================================================

// Renderable primitive types
enum PrimitiveType : byte {
    POINTS,
    LINES,
    LINE_LOOP,
    LINE_STRIP,
    TRIANGLES,
    TRIANGLE_STRIP,
    TRIANGLE_FAN // Not recommended, some hardware support is lacking
}

enum AttributeSemantic : byte {
    POSITION, // for the moment, must be a vec3.
    NORMAL,   // for the moment, must be a vec3.
    TANGENT,  // for the moment, must be a vec3.
    TEXTURE,  // for the moment, is either a vec2, or normalized u16vec2
    COLOR,    // normalized u8vec4, or vec4
}

// Interpret a buffer view as a strided pack of vector or matrix elements
table Attribute {
    view     : BufferViewID;
    semantic : AttributeSemantic;
    
    // some semantics may have a channel; there could be multiple of these
    // attributes for this mesh. For now
    //  textures and colors.
    // may have extra channels. Implementations need not support more than 1
    channel  : byte;      

    stride   : uint64 = 0; // bytes between elements
    format   : Format;     // format of the element

    minimum_value : Vec4; // optional bounds for this attribute
    maximum_value : Vec4; // optional bounds for this attribute

    // are the elements normalized?
    // for example a normalized U8: 0 -> 0, 255 -> 1.
    normalized : bool = false; 
}

table IndexSemantic {
    view     : BufferViewID;
    // bytes between indicies. for performance, recommend all indicies be 
    // tightly packed, with no padding.
    stride : uint64 = 0; 
    format : Format;     // format of the indicies, u8, u16, u32
}

table GeometryPatch {
    attributes : [Attribute];

    // optional, if missing, non-indexed primitives only
    indicies   : IndexSemantic; // u8, u16, u32

    type : PrimitiveType = TRIANGLES;

    material : MaterialID; // Material to use for rendering this patch
}

table GeometryCreate {
    id      : GeometryID (required); // id of the new geometry
    name    : string;
    patches : [ GeometryPatch ];    
}

table GeometryDelete {
    id : GeometryID (required);
}

// =============================================================================

// non-atomic update semantics
table TableCreateUpdate {
    // ID of the new table to create
    id           : TableID (required);
    name         : string; // name of the table
    meta         : string; // application defined metadata
    methods_list : [ MethodID ]; // methods attached
    signals_list : [ SignalID ]; // signals attached
}

table TableDelete {
    id : TableID (required);
}

// =============================================================================

// Update the core document properties
// non-atomic update semantics
table DocumentUpdate {
    methods_list  : [ MethodID ];
    signals_list  : [ SignalID ];
}

// Ask to reset the document. All entities, objects, tables, etc, are now 
// invalid.
table DocumentReset {
    padding : bool; // these things cannot be empty, so...
}

// =============================================================================

// Clients should invoke the given signal on the given context
table SignalInvoke {
    // ID of signal to invoke
    id  : SignalID (required);

    // if not set, the context is on the document
    context : InvokeIDType;

    // Arguments to the signal
    signal_data  : AnyList;
}

// Information about method exceptions
// This is modelled after JSONRPC error handling and exceptions.
table MethodException {
    code    : int64;  // required (but not expressable in fbs)
    message : string; // optional
    data    : Any;    // optional
}

// A reply to a method invocation.
table MethodReply {
    invoke_ident     : string (required); // the client provided invoke ident
    method_data      : Any;             // optional, method return value
    method_exception : MethodException; // optional, possible exception
}

// =============================================================================

union ServerMessageType {
    MethodCreate,
    MethodDelete,
    SignalCreate,
    SignalDelete,
    EntityCreateUpdate,
    EntityDelete,
    BufferCreate,
    BufferDelete,
    BufferViewCreate,
    BufferViewDelete,
    MaterialCreateUpdate,
    MaterialDelete,
    TextureCreate,
    TextureDelete,
    SamplerCreate,
    SamplerDelete,
    ImageCreate,
    ImageDelete,
    LightCreateUpdate,
    LightDelete,
    GeometryCreate,
    GeometryDelete,
    TableCreateUpdate,
    TableDelete,
    DocumentUpdate,
    DocumentReset,
    SignalInvoke,
    MethodReply
}

table ServerMessage {
    message : ServerMessageType;
}

// Root type for server messages. This is the only type that is to be sent from // the server.
table ServerMessages {
    messages : [ ServerMessage ];
}

// =============================================================================
// Client Messages =============================================================
// =============================================================================

// Introduction of the client to the server, must be the first message sent by 
// the client, and the server will not respond until it gets such a message
table IntroductionMessage {
    client_name : string (required); // A human-friendly name of the client
}

// Client asks to invoke a method or function, i.e. RPC
table MethodInvokeMessage {
    method_id : MethodID (required);

    // Context, or which thing should this method be invoked on
    // If not set, it is on the document
    context : InvokeIDType;

    // An optional, client created identifier for this invocation request.
    // If blank, the server will not send any response, i.e. fire and forget 
    //semantics.
    invoke_ident : string;

    // Arguments for this method.
    method_args  : AnyList;
}

union ClientMessageType {
    IntroductionMessage,
    MethodInvokeMessage,
}

table ClientMessage {
    content : ClientMessageType (required);
}

// Root type for client messages, this is the type that must be sent from 
// clients.
table ClientMessages {
    messages : [ ClientMessage ] (required);
}
