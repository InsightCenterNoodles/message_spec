// Generate with
// flatc --scoped-enums --reflect-names --gen-mutable -c noodles.fbs

namespace noodles;

// =============================================================================
// Common Types ================================================================
// =============================================================================

// Identifiers are tables, due to poor language support for structs.

table ObjectID {
    id_slot : uint32;
    id_gen  : uint32;
}

table PlotID {
    id_slot : uint32;
    id_gen  : uint32;
}

table TableID {
    id_slot : uint32;
    id_gen  : uint32;
}

table SignalID {
    id_slot : uint32;
    id_gen  : uint32;
}

table MethodID {
    id_slot : uint32;
    id_gen  : uint32;
}

table MaterialID {
    id_slot : uint32;
    id_gen  : uint32;
}

table GeometryID {
    id_slot : uint32;
    id_gen  : uint32;
}

table LightID {
    id_slot : uint32;
    id_gen  : uint32;
}

table TextureID {
    id_slot : uint32;
    id_gen  : uint32;
}

table BufferID {
    id_slot : uint32;
    id_gen  : uint32;
}

union AnyIDType {
    ObjectID,
    TableID,
    SignalID,
    MethodID,
    MaterialID,
    GeometryID,
    LightID,
    TextureID,
    BufferID,
    PlotID
}

table AnyID {
    id : AnyIDType (required);
}

table MapEntry {
    name  : string (key);
    value : Any;
}

table Text { text : string; }
table Integer { integer : int64; }
table IntegerList { integers : [int64]; }
table Real { real : double; }
table RealList { reals : [double]; }
table Data { data : [byte]; }
table AnyList { list : [Any]; }
table AnyMap { entries : [MapEntry]; }

union AnyType {
    Text,
    Integer,
    IntegerList,
    Real,
    RealList,
    Data,
    AnyList,
    AnyMap,
    AnyID
}

table Any {
    any : AnyType;
}

// Misc Types ==================================================================

struct Vec2 {
    x : float;
    y : float;
}

struct Vec3 {
    x : float;
    y : float;
    z : float;
}

struct Vec4 {
    x : float;
    y : float;
    z : float;
    w : float;
}

struct Mat4 {
    // for javascript compat, we have to expand this.
    // components : [float : 16];
    c1 : Vec4;
    c2 : Vec4;
    c3 : Vec4;
    c4 : Vec4;
}

struct BoundingBox {
    aabb_min : Vec3;
    aabb_max : Vec3;
}

table BufferRef {
    id    : BufferID;
    start : uint64;
    size  : uint64;
}

struct RGB {
    r : uint8;
    g : uint8;
    b : uint8;
}

// =============================================================================
// Server Messages =============================================================
// =============================================================================

table MethodArg {
    name : string;
    doc  : string;
    hint : string;
}
table MethodCreate {
    id            : MethodID (required);
    name          : string;
    documentation : string;
    return_doc    : string;
    arg_doc       : [ MethodArg ];
}

table MethodDelete {
    id            : MethodID (required);
}

// =============================================================================

table SignalCreate {
    id             : SignalID (required);
    name           : string;
    documentation  : string;
    arg_doc        : [ MethodArg ];
}

table SignalDelete {
    id             : SignalID (required);
}

// =============================================================================

table EmptyDefinition {
    padding : bool = false; // cannot be empty
}

// atomic update semantics
table TextDefinition { // Text plane, normal +z, up is +y, center: obj origin
    text   : string (required); // String to render
    font   : string (required); // Approximate font to use (e.g. Arial)
    height : float = .25; // The height of the text plane.
    width  : float = -1; // Optional width of text, infer from height if < 0
}

// atomic update semantics
table WebpageDefinition {
    url    : string (required);
    height : float = .5;
    width  : float = .5;
}

// atomic update semantics
table RenderableDefinition {
    material    : MaterialID (required);
    mesh        : GeometryID (required);
    instances   : [Mat4]; // optional
    instance_bb : BoundingBox; // optional override for instanced object culling
}

union ObjectDefinition {
    EmptyDefinition,
    TextDefinition,
    WebpageDefinition,
    RenderableDefinition
}

struct ObjectVisibility {
    visible : bool;
}

// nonatomic update semantics
table ObjectCreateUpdate {
    id           : ObjectID (required);
    name         : string;
    parent       : ObjectID;
    transform    : Mat4;
    definition   : ObjectDefinition;
    lights       : [LightID];
    tables       : [TableID];
    plots        : [PlotID];
    tags         : [string];
    methods_list : [MethodID];
    signals_list : [SignalID]; // Dont use "signals" to avoid Qt conflict.
    influence    : BoundingBox;
    visibility   : ObjectVisibility;
}

table ObjectDelete {
    id        : ObjectID (required);
}

// =============================================================================

table SimplePlot {
    definition : string (required);
}

table URLPlot {
    url : string (required);
}

union PlotType {
    SimplePlot,
    URLPlot
}

// non-atomic update semantics
table PlotCreateUpdate {
    id           : PlotID (required);
    table        : TableID;
    type         : PlotType;
    methods_list : [MethodID];
    signals_list : [SignalID];
}

table PlotDelete {
    id        : PlotID (required);
}

// =============================================================================

table BufferCreate {
    id       : BufferID (required);
    bytes    : [byte]; // This could be empty
    url      : string; // This could be empty too
    size     : uint64; // Size of buffer

    // If both are empty, data is coming, just hang on for another message of
    // this kind with the bytes. you may have to request a refresh message
}

table BufferDelete {
    id    : BufferID (required);
}

// =============================================================================

// non-atomic update semantics
table MaterialCreateUpdate {
    id           : MaterialID (required);
    color        : Vec4;
    metallic     : float;
    roughness    : float;
    use_blending : bool;
    texture_id   : TextureID;
}

table MaterialDelete {
    id           : MaterialID (required);
}

// =============================================================================

// non-atomic update semantics
table TextureCreateUpdate {
    id        : TextureID (required);
    reference : BufferRef (required);
}

table TextureDelete {
    id        : TextureID (required);
}

// =============================================================================

enum LightType : byte {
    POINT = 0,
    SUN, //Direct light along +Z
}

// non-atomic update semantics
table LightCreateUpdate {
    id         : LightID (required);
    color      : RGB;
    intensity  : float;
    spatial    : Vec4;
    light_type : LightType; // after being set once, updates ignored
}
table LightDelete {
    id        : LightID (required);
}

// =============================================================================

table ComponentRef { // All elements required, but not expressable in this spec
    id     : BufferID (required);
    start  : uint64;
    size   : uint64;
    stride : uint64;
}

table GeometryCreate {
    id         : GeometryID (required);

    extent : BoundingBox;

    positions  : ComponentRef; // Vec3
    normals    : ComponentRef; // Vec3
    tex_coords : ComponentRef; // Vec2
    colors     : ComponentRef; // U8Vec4
    lines      : ComponentRef; // U16Vec2
    triangles  : ComponentRef; // U16Vec3
}

table GeometryDelete {
    id : GeometryID (required);
}

// =============================================================================

// non-atomic update semantics
table TableCreateUpdate {
    id           : TableID (required);
    name         : string;
    meta         : string;
    methods_list : [ MethodID ];
    signals_list : [ SignalID ];
}

table TableDelete {
    id      : TableID (required);
}

// =============================================================================

table DocumentUpdate {
    methods_list  : [ MethodID ];
    signals_list  : [ SignalID ];
}

table DocumentReset {
    padding : bool; // these things cannot be empty, so...
}

// =============================================================================

table SignalInvoke {
    id  : SignalID (required);

    // if the two below are not set, it is on the document
    on_object : ObjectID;
    on_table  : TableID;
    on_plot   : PlotID;

    signal_data  : AnyList;
}

table MethodException {
    code    : int64;  // required
    message : string; // optional
    data    : Any;    // optional
}

table MethodReply {
    invoke_ident     : string (required);
    method_data      : Any;             // optional
    method_exception : MethodException; // optional
}

// =============================================================================

union ServerMessageType {
    MethodCreate,
    MethodDelete,
    SignalCreate,
    SignalDelete,
    ObjectCreateUpdate,
    ObjectDelete,
    BufferCreate,
    BufferDelete,
    MaterialCreateUpdate,
    MaterialDelete,
    TextureCreateUpdate,
    TextureDelete,
    LightCreateUpdate,
    LightDelete,
    GeometryCreate,
    GeometryDelete,
    TableCreateUpdate,
    TableDelete,
    DocumentUpdate,
    DocumentReset,
    SignalInvoke,
    MethodReply
}

table ServerMessage {
    message : ServerMessageType;
}

// Root type for server messages
table ServerMessages {
    messages : [ ServerMessage ];
}

// =============================================================================
// Client Messages =============================================================
// =============================================================================

table IntroductionMessage {
    client_name : string (required);
    version : uint32 = 0;
}

table MethodInvokeMessage {
    method_id : MethodID (required);

    // if any of the below is not set, it is on the document
    on_object : ObjectID;
    on_table  : TableID;
    on_plot   : PlotID;

    invoke_ident : string (required);
    method_args  : AnyList;
}

table AssetRefreshMessage {
    for_buffers : [ BufferID ] (required);
}

union ClientMessageType {
    IntroductionMessage,
    MethodInvokeMessage,
    AssetRefreshMessage
}

table ClientMessage {
    content : ClientMessageType (required);
}

// Root type for client messages
table ClientMessages {
    messages : [ ClientMessage ] (required);
}